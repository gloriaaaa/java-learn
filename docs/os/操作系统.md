# 计算机操作系统 - 概述

操作系统是硬件上层的第一层软件。

## 基本特征

### 1. 并发

- 并发：一段时间间隔内能同时运行多个程序
- 并行：同一时刻能运行多个指令。并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

### 2. 共享

共享是指系统中的资源可以被多个并发进程共同使用。有两种资源共享方式：
- 互斥共享：临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问
- 同时共享：如磁盘设备，允许一段时间内由多个进程同时访问（宏观上同时，微观上可能是分时共享的）

### 3. 虚拟

虚拟技术把一个物理实体转换为多个逻辑实体。
- 时（时间）分复用技术：如多个进程能在同一个处理器上并发执行，每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。
- 空（空间）分复用技术：如虚拟内存，将物理内存抽象为地址空间，地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 4. 异步

不可预知，进程的执行走走停停，执行顺序不确定。

## 基本功能

- 进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等。
- 内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等。
- 文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等。
- 设备管理：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 操作系统提供的接口
- 命令接口：用户利用这些操作命令来组织和控制作业的执行。
    - 联机命令接口：分时/实时系统，强调交互性
    - 脱机命令接口：批处理系统
- 程序接口：编程人员使用它们来请求操作系统服务。程序接口由一组系统调用(广义指令)。图形接口最终通过调用程序接口实现，图形接口不是操作系统的一部分，但图形接口所调用的系统调用命令是操作系统的一部分。

## 操作系统的发展
- 手工阶段：无操作系统，缺点：人机矛盾
- 批处理阶段
    - 单道批处理：缺点：资源利用率低系统吞吐量小
    - 多道批处理：缺点：交互性差
- 分时操作系统：高优先级的线程没有办法优先解决。有些时候需要对外部信息在规定的时间(比时间片的时间还短)内处理
- 实时操作系统

## 操作系统内核中包括什么
- 时钟管理 
    - 时间片轮转
    - 时钟中断、进程切换
- 中断机制
    - 操作系统本质是中断服务程序
- 原语
    - 操作系统内部可被调用的公用小程序，要么都做要么都不做
- 系统控制的数据结构
    - 系统中用来登记状态信息的数据结构

## 中断分类
- 硬件中断
    - 外中断：由 CPU 执行指令以外的事件引起，可屏蔽
        - 例： I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。还有时钟中断、控制台中断等
    - 内中断：由 CPU 执行指令的内部事件引起，不可屏蔽
        - 例：非法操作码、地址越界、算术溢出、除0、虚存系统的缺页。
- 软件中断
    - trap：在用户程序中使用系统调用。
        - 例：进程创建、管道创建、文件夹创建

## 用户态、内核态、中断流程
操作系统的很多操作会消耗系统的物理资源，例如创建一个新进程时，要做很多底层的工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能让任何程序都可以做。

在Linux操作系统操作系统的设计中主要采用了0和3两个特权级，也就是我们通常所说的内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上也没有限制。

当一个任务（进程）陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。每个进程都有自己的内核栈和用户栈，当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态），此时处理器在特权级最低的（3 级）用户代码中运行。简单来说在内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。

Linux进程的 4GB 地址空间，3G-4G是内核态的地址空间，存放整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程运行在用户态，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作。这时必须切换到Ring 0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后切换回Ring 3，回到用户态。当程序处于内核态时可以随意进入用户态。

很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。用户态切换到内核态的3种方式：

* `系统调用`：这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。
* `产生异常`：CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会切换到内核态，如缺页异常。
* `外围设备的中断`：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换

## 系统调用
如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

Linux 的系统调用主要有以下这些：

| Task | Commands |
| :---: | --- |
| 进程控制 | fork(); exit(); wait(); |
| 进程通信 | pipe(); shmget(); mmap(); |
| 文件操作 | open(); read(); write(); |
| 设备操作 | ioctl(); read(); write(); |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全 | chmod(); umask(); chown(); |

## 大内核和微内核

- 大内核：将操作系统功能作为一个紧密结合的整体放到内核。
    - 优点：由于各模块共享信息，因此有很高的性能。
    - 缺点：复杂的交互关系使得层次之间的界限极其模糊。
- 微内核：由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。
    - 优点：有效地分离了内核与服务、服务与服务，接口清晰、维护代价低、可靠性强。(服务越少越稳定)
    - 缺点：需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。


